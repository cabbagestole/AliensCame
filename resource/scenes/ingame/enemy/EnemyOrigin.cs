using Godot;
using System;

// note
// Alien origin node.
// As the origin moves, the aliens positioned relative to it move together.
// エイリアンの原点となるノード。
// 原点が移動することにより、相対的に配置されたエイリアンも一緒に移動します。
//
public partial class EnemyOrigin : NotifiableNode2D
{

	[Export] private PackedScene MartianOctopus { get; set; }
	[Export] private PackedScene Gray { get; set; }
	[Export] private PackedScene FlatwoodsMonster { get; set; }
	[Export] public float Speed = 1;
	
	private bool _isTouch = false;
	private Direction _direction = Direction.East;
	private Timer _timer;
	private int _enemyCount = 0;
	
	public override void _Ready()
	{
		Position = (GetViewportRect().Size * (float)0.1);
		for(int y = 0; y < 5 ; y++){
			for(int x = 0; x < 8 ; x++){
				if(y == 0) 
					generate(MartianOctopus, x, y);
				if((y == 1)||(y ==2)) 
					generate(Gray, x, y);
				if((y == 3)||(y ==4)) 
					generate(FlatwoodsMonster, x, y);
			}
		}
		_timer = GetNode<Timer>("Timer");
		_timer.Start(2);

	}

	private bool isStop = false;
	public void stopMoving()
	{
		isStop = true;
	}


	public override void _Process(double delta)
	{
		if(isStop) return;
		float x = 0;
		float y = 0;
		float ratio = 1 / Mathf.Sqrt(_enemyCount +1);
		if(_direction == Direction.East) {
			x = Speed * ratio;
		} else {
			x = -Speed * ratio;
		}
		if(_isTouch){
			y = 16;
			_isTouch = false;
		}
		Vector2 next = Position;
		next.X += x;
		next.Y += y;
		Position = next;
	}

	private void generate(PackedScene enemyScene, float x, float y)
	{
		generateImpl(enemyScene, x * 48, y * 48);
	}

	// note
	// The scene generated by Instantiate() from a packedScene 
	// can be any of MartianOctopus, Gray, or FlatwoodsMonster, 
	// but here it can be processed as an EnemyBase type.
	// 引数に与えられたpackedSceneからInstantiate()して
	// 生成されるシーンはMartianOctopus,Gray,FlatwoodsMonsterの何れかですが、
	// ここではEnemyBase型として処理可能です。
	//
	private void generateImpl(PackedScene enemyScene, float x, float y)
	{
		EnemyBase enemy = (EnemyBase)enemyScene.Instantiate();
		enemy.AddTouchObserver(touch);
		enemy.AddDeathObserver(death);
		enemy.AddInvadeObserver(invade);
		enemy.Position = new Vector2(x, y);
		AddChild(enemy);
		_enemyCount++;
	}

	// note
	// Called when the alien reaches the left or right edge.
	// エイリアンが左右端に到達した時、呼び出される。
	//
	private void touch(Direction direction)
	{
		_direction = direction;
		_isTouch = true;
	}

	// note
	// Called when an alien is destroyed.
	// エイリアンが破壊されたとき呼び出される。
	//
	private void death()
	{
		_enemyCount--;
		if(0 >= _enemyCount)
			notifyObservers();
	}

	// note
	// Called when the alien comes to the bottom level.
	// エイリアンが最下段に来た時、呼び出される。
	// 
	private bool isNotify = false;
	private void invade()
	{
		if(isNotify) return;
		isNotify = true;
		InGame parent = (InGame)GetParent();// Not good. Jumper lines that I write because I know my parents are InGame. 
		parent.invade();
	}


	// note
	// An event handler that is called 
	// when the time limit for firing bullets has expired.
	// Since EnemyOrigin's child nodes also include Timer, 
	// Timer is elected when the argument of GetChild() is 0.
	// However, the class cast to Enemybase fails and the enemy becomes null,
	// so the enemy?Fire() is not executed.
	// The last one of the aliens will stop firing bullets, 
	// but this is not a problem for the Game balance.
	//
	// 弾を発射する時限がきたとき呼びされるイベントハンドラ。
	// EnemyOriginの子ノードにはTimerも含まれるため、
	// GetChild()の引数が0の時はTimerが選出される。
	// しかしEnemybaseへのクラスキャストが失敗しenemyがnullになるため、
	// enemy?Fire()は実行されない。
	// エイリアンが最後の１体になると弾を発射しなくなるが、
	// ゲームバランスとしては問題ないでしょう。
	// 
	private void OnTimerTimeout()
	{
		if(isStop) return;
		int count = GetChildCount() -1;//EnemyBaseの子ノードTimerの分を -1し、Enemybaseの数を得る
		if(0 <= count) {
			EnemyBase enemy = GetChild((int)GD.Randi() % count) as EnemyBase;
			enemy?.Fire();
			_timer.Start();
		}
	}


}


